// Практическое задание.

// Курс: Разработка интерфейса на JavaScript.
// Дисциплина: Основы JavaScript.

// Практическое задание №28: Прототипы. Контекст. Виды функций. Замыкания.

// Задачи из занятия:

// Задача 1.
// Условие: Комбинирование прототипа и контекста.
// Суть: Написать функцию, которая умножает каждое число массива на заданное число с использованием map и this.

// Задача 2.
// Условие: Замыкание с добавлением.
// Суть: Написать функцию, которая возвращает другую функцию, прибавляющую фиксированное значение (через замыкание).

// Задача 3.
// Условие: Прототип + конструктор.
// Суть: Создать конструктор Person, который имеет метод sayHi, а через prototype добавить sayBye.

// Задача 4.
// Условие: Контекст this и bind.
// Суть: Привязать функцию greet к объекту person так, чтобы this.name всегда указывал на "Алексей".

// Задача 5.
// Условие: Переписать обычную функцию как стрелочную.
// Суть: Функция sum(a, b) — переписать в стрелочную форму const sum = (a, b) => a + b;.

// Задача 6.
// Условие: Валидатор пароля.
// Суть: Функция createPasswordChecker(minLength) возвращает другую функцию, проверяющую, длиннее ли пароль.

// Задача 7.
// Условие: Генератор ID.
// Суть: Написать функцию, возвращающую другую, которая при каждом вызове возвращает уникальный ID (через замыкание).










// ========================
// Задача: Умножить массив на число с использованием контекста (this) и map
// ========================

/**
 * Функция принимает массив чисел и множитель,
 * затем возвращает новый массив, где каждое число умножено на заданный множитель.
 * Здесь используется метод .map() и передаётся объект в качестве контекста this.
 */
function multiplyArray(arr, multiplier) {
    return arr.map(function (num) {
      return num * this.factor; // this.factor берётся из второго аргумента map()
    }, { factor: multiplier }); // объект с ключом factor становится контекстом this
  }
  console.log("Задача: Умножение массива:", multiplyArray([1, 2, 3], 5)); // [5, 10, 15]
  
  
  // ========================
  // Задача: Замыкание с прибавлением определённого числа
  // ========================
  
  /**
   * Создаёт функцию, которая будет прибавлять к числу заданное значение numToAdd.
   * Это пример замыкания: внутренняя функция "помнит" переменную из внешней.
   */
  function createAdder(numToAdd) {
    return function (value) {
      return value + numToAdd;
    };
  }
  const addTen = createAdder(10);
  console.log("Задача: Замыкание-сложение:", addTen(5)); // 15
  
  
  // ========================
  // Задача 2: Конструктор Person и методы через prototype
  // ========================
  
  /**
   * Функция-конструктор Person создаёт объект с именем и методом sayHi.
   * Метод sayBye добавляется в прототип, чтобы не дублировался в каждом экземпляре.
   */
  function Person(name) {
    this.name = name;
    this.sayHi = function () {
      console.log("Привет,", this.name);
    };
  }
  
  // Добавляем метод в прототип
  Person.prototype.sayBye = function () {
    console.log("Пока,", this.name);
  };
  
  const user = new Person("Анна");
  user.sayHi(); // Привет, Анна
  user.sayBye(); // Пока, Анна
  
  
  // ========================
  // Задача 4: Привязка контекста через bind
  // ========================
  
  /**
   * Функция greet выводит this.name.
   * Мы создаём объект и привязываем к нему эту функцию через .bind()
   * чтобы она всегда работала в его контексте.
   */
  function greet() {
    console.log("Привет,", this.name);
  }
  const person = { name: "Алексей" };
  const boundGreet = greet.bind(person);
  boundGreet(); // Привет, Алексей
  
  
  // ========================
  // Задача 6: Перепиши функцию sum как стрелочную
  // ========================
  
  /**
   * Короткая запись обычной функции с помощью стрелочного синтаксиса.
   */
  const sum = (a, b) => a + b;
  console.log("Сумма:", sum(3, 5)); // 8
  
  
  // ========================
  // Задача 7: createPasswordChecker
  // ========================
  
  /**
   * Возвращает функцию-проверку пароля по минимальной длине.
   * Это тоже пример замыкания — minLength "запоминается" внутри.
   */
  function createPasswordChecker(minLength) {
    return function (password) {
      return password.length > minLength;
    };
  }
  
  const checkPassword = createPasswordChecker(8);
  console.log("Проверка пароля (короткий):", checkPassword("123456")); // false
  console.log("Проверка пароля (длинный):", checkPassword("123456789")); // true
  
  
  // ========================
  // Задача 8: Генератор уникальных ID (замыкание)
  // ========================
  
  /**
   * Функция возвращает другую функцию, которая каждый раз увеличивает счётчик.
   * Таким образом генерируются уникальные ID. Пример замыкания.
   */
  function createIdGenerator() {
    let current = 1; // переменная, сохраняющая текущее значение счётчика
    return function () {
      return current++; // каждый раз увеличиваем и возвращаем
    };
  }
  
  const getNextId = createIdGenerator();
  console.log("ID 1:", getNextId()); // 1
  console.log("ID 2:", getNextId()); // 2
  console.log("ID 3:", getNextId()); // 3



